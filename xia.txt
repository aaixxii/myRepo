全体１：
⇒segmentRepository.insertSegment(segInfo)が成功して、
　segmentLoadRepository.insertSegmentLoad(segLoading);で例外が起きた場合、
　そのセグメントはどのNSMにも配られないままになるのではないか？

142~146行目：		if (segInfo.getVersion() != null) {
						segLoading.setLastVersion(segInfo.getVersion());
					} else {
						segInfo.setVersion(-1L);
					}
⇒NewSegmentなのでここではバージョンは常に-1が正しい認識。
　クライアントが指定したものにした場合は初期値がそうなってしまうので実際の更新回数と異なるのでは？
　またこの時点ではsegment_loading.last_versionは-1が正しいのでは？
　（segment_loading.last_versionの意味が「アサインするセグメントの最新バージョン」なのか
　　「NSMが申告するそのセグメントの最新バージョン」なのかで↑の指摘も変わるがどちらが正しい？）

151～159行目：
⇒e instanceof DuplicateKeyExceptionのときのみreturnしているがsegments_infoにインサートできていない時点で
　以降の処理はできない（してはいけない）のではないか？

197～215行目：
⇒165行目のsegmentLoadRepository.insertSegmentLoad(segLoading);が失敗している場合ここのupdateも失敗となる。
　MysqlなのでINSERT ... ON DUPLICATE KEY UPDATE 構文で対象があればUPDATE,なければINSERTとするのがいいのではないか？

198行目：segmentRepository.updateAfterNew(-9, segInfo.getSegmentId());
⇒NSM通信失敗時に上記を更新しているがsegment_infoテーブルはあくまでsegment情報を更新しているだけなのでここでの更新は不要。
　※206行目のsegment_loadingの情報は必要
　219～226行目も同様

211行目：mustSetMailFlag = true;
⇒215行目でいずれのケースでもmustSetMailFlag = trueにしているのでここでは不要

246行目：mmLastReturnValue = lastSegmentUpdateSuccess;
⇒SEGMENT_SYNC_COMMAND_NEWのときはsegment_loadingも必要なのでソース上以下が正しい。
　mmLastReturnValue = lastSegmentUpdateSuccess && lastSegmentLoadUpdateSuccess;
　

NSMの情報を取得（SEGMENT_SYNC_COMMAND_NEWの場合）

select * from node_storage_manager where status=1 and space>0 order by space DESC limit ?

NSMの情報を取得（SEGMENT_SYNC_COMMAND_NEW以外の場合）

select n.* from node_storage_manager n, segment_loading s where n.status =1 and n.nsm_id = s.nsm_id and s.segment_id=? limit ?

h3. ★Dispatcher.java#processTempalteInsert

287～294行目：
⇒製品版では不要の認識

300行目：segmentLoadRepository.getLastVersion(one.getNsmId(), segInfo.getSegmentId());
⇒ここでSQLExceptionが発生するとresult=trueでクライアントに結果が返ってしまう。

338行目：result = Boolean.FALSE
⇒ここではすでにresult = Boolean.FALSEになっているので不要

h3. ★Dispatcher.java#processTempalteDelete

398～403行目：
⇒製品版では不要の認識

410行目：segmentLoadRepository.getLastVersion(one.getNsmId(), segInfo.getSegmentId());
⇒ここでSQLExceptionが発生するとresult=trueでクライアントに結果が返ってしまう。

451行目：result = Boolean.FALSE
⇒454行目で同じことをやるのでここでは不要
