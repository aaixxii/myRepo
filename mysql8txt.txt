1、linux下mysql安装完后是默认：区分表名的大小写，不区分列名的大小写； 
2、用root帐号登录后，在/etc/my.cnf 中的[mysqld]后添加添加lower_case_table_names=1，重启MYSQL服务，这时已设置成功：不区分表名的大小写； 
lower_case_table_names参数详解： 
lower_case_table_names = 0 
其中 0：区分大小写，1：不区分大小写 
MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的： 
　　 1、数据库名与表名是严格区分大小写的； 
　　 2、表的别名是严格区分大小写的； 
　　 3、列名与列的别名在所有的情况下均是忽略大小写的； 
　　 4、变量名也是严格区分大小写的； 
MySQL在Windows下都不区分大小写。 
3、如果想在查询时区分字段值的大小写，则：字段值需要设置BINARY属性，设置的方法有多种： 
A、创建时设置： 
CREATE TABLE T( 
A VARCHAR(10) BINARY 
); 
B、使用alter修改： 
ALTER TABLE `tablename` MODIFY COLUMN `cloname` VARCHAR(45) BINARY; 
C、mysql table editor中直接勾选BINARY项。 








1、使用truncate table test;方法清空表，id字段自动重置，重新从1开始递增。
2、使用delete删除表中所有或部分记录后，让id字段从中间某个数值进行递增。此时可以修改auto_increment数值。
alter table testAUTO_INCREMENT=1;
3、也可以通过navicat mysql工具，设计表时在选项这个tab栏中修改自动递增的当前值。

jpa:
  hibernate:
    ddl-auto: create
    naming:
      physical-strategy: org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy
  show-sql: true
  open-in-view: true
  database: MYSQL
  properties:
    hibernate:
      dialect: org.hibernate.dialect.MySQL8Dialect
      connect:
        autoReconect: true

c3p0.properties
c3p0.jdbcUrl=jdbc:mysql://localhost:3306/strive?useSSL=false&autoReconnect=true&serverTimezone=UTC
c3p0.user=ENC(xYABcNO57ppZsDVftm7Tvw==)
c3p0.password=ENC(O1KV/2eMOeQbW/k964UeH5LueyFI5fC+)
c3p0.driverClass=com.mysql.cj.jdbc.Driver
c3p0.minPoolSize=2
c3p0.maxPoolSize=10
c3p0.maxIdleTime=1800000
c3p0.acquireIncrement=3
c3p0.maxStatements=1000
c3p0.initialPoolSize=3
c3p0.idleConnectionTestPeriod=60
c3p0.acquireRetryAttempts=30
c3p0.acquireRetryDelay=1000
c3p0.breakAfterAcquireFailure=false
c3p0.testConnectionOnCheckout=false

MySQL空间扩展不仅提供了空间数据的存储能力，而且还具备一些空间运算能力，这些功能通过MySQL内建的几何函数实现。最简单的几何函数昨天已经有所涉及，也就是转换WTK的GEOMFROMTEXT和ASTEXT。除此以外，不同的几何对象还具有不同的功能函数。

几何类的函数
DIMENSION，返回对象的尺寸，-1为空，0为点（没有长度没有面积），1为线（有长度而没有面积），2为多边形（有面积）；
ENVELOPE，返回最小边界矩形；
GEOMERYTYPE，返回几何类型（字符串）
SRID，所谓SRID是空间基准坐标指示符，表示一个几何类型的坐标系统。

点对象的函数
X，Y两个函数用于返回点的X坐标和Y坐标

线对象的函数
GLENGTH，返回线长
ISCLOSED，是否为封闭线段
NUMPOINTS，线段包含点的数目
STARTPOINT，ENDPOINT，POINTN，分别返回起点，终点和指定位置的点

多边形对象的函数
AREA，返回多边形面积
EXTERIORRING，返回线型的外环
INTERIORRINGN，返回指定的内环（对于包含空洞的多边形）
NUMINTERIORRINGS，返回空洞数目

几何集合对象的函数
GEOMETRYN，返回指定位置的几何类型
NUMGEOMETRIES，返回对象数目

空间分析操作函数
OpenGIS的空间分析操作函数目前还没有被MySQL完全支持，包括作缓冲区、联合、切割等操作还不能通过MySQL直接完成。

最小边界矩形空间关系函数
MySQL提供了一组函数来判断几个对象和最小边界矩形的位置关系
MBRCONTAINS
MBRDISJOINT
MBREQUAL
MBRINTERSECTS
MBROVERLAPS
MBRTOUCHES
MBRWITHIN

几何对象空间关系函数
MySQL5尚未实现以下几何对象的空间关系分析功能。
CONTAINS
CROSSES
DISJOINT
DISTANCE
EQUALS
INTERSECTS
OVERLAPS
RELATED
TOUCHES
WITHIN

ALTER TABLE product ADD discount_price DECIMAL(9,2) as (if(discount!=-1,price*discount/100,price)) VIRTUAL;

设置GLOBAL与SESSION范围变量
可以通过SET命令设置MySQL参数。按照变量范围可以将变量的设置分为：
GLOBAL：设置应用于所有的数据库连接
SESSION：设置应用于当前数据库连接
例如，如果你想要记录时间大于1秒的所有查询，你可以执行：
mysql> SET GLOBAL long_query_time = 1;
如果想要在重启后持久保存这个参数，可以执行：
mysql> SET PERSIST long_query_time = 1;
Query OK, 0 rows affected (0.01 sec)
或：
mysql> SET @@persist.long_query_time = 1;
Query OK, 0 rows affected (0.00 sec)
假如你只需要对当前连接查询进行记录，你可以执行：
mysql> SET SESSION long_query_time = 1;

MySQL有两种类型的参数：
静态：这种类型的参数在MySQL服务重启后生效
动态：动态改变参数，不需要重启MySQL服务
变量的值可以通过以下方式进行设置
配置文件：MySQL有一个配置文件，可以在其中指定数据存储目录，MySQL使用的内存和多种其它参数。
启动脚本：你可以直接将参数传给 mysqld 进程。它仅在服务运行时有效。
使用SET命令（仅仅用于动态变量）：服务重启后失效。你需要将这些变量设置到配置文件中，保证参数能够持久化保存，重启依然生效。另一种方式就是在设置变量时加上PERSIST或者@@persist前缀。
使用配置文件
在Red Hat和CentOS系统中MySQL黙认的配置文件是 /etc/my.cnf，在Debian系统中是 /etc/mysql/my.cnf。使用编辑器打开配置文件可以进行相关的参数配置。
MySQL的配置文件会以区域名称分成几个区域，所有与该区域相关的参数都配置在此区域名称的下方，配置文件形如：

[mysqld] <---section name
<parameter_name> = <value> <---parameter values
[client]
<parameter_name> = <value>
[mysqldump]
<parameter_name> = <value>
[mysqld_safe]
<parameter_name> = <value>
[server]
<parameter_name> = <value>
[mysql]：这个区域的配置参数是由mysql命令行客户端读取的
[client]：这个区域的配置参数是由与MySQL服务连接的客户端读取的（包括mysql cli）
[mysqld]：这个区域的配置参数是由MySQL的备份工具mysqldump读取的
[mysqld_safe]：这个区域的配置参数是由mysqld_safe进程（MySQL服务启动脚本）读取的
另外，mysqld_safe进程会读取配置文件中[mysqld]和[server]这两个区域的所有选项。
例如下面的配置，mysqld_safe进程会读取mysqld区域中的pid-file选项。

shell> sudo vi /etc/my.cnf
[mysqld]
pid-file = /var/lib/mysql/mysqld.pid
在使用systemd的系统中，并未安装mysqld_safe。要配置启动脚本，需要在 /etc/systemd/system/mysqld.service.d/override.conf文件中设置一些值：

[Service]
LimitNOFILE=max_open_files
PIDFile=/path/to/pid/file
LimitCore=core_file_limit
Environment="LD_PRELOAD=/path/to/malloc/library"
Environment="TZ=time_zone_setting"

mysql> SET GLOBAL event_scheduler = ON;

mysql> DROP EVENT IF EXISTS purge_salary_audit;
DELIMITER $$
CREATE EVENT IF NOT EXISTS purge_salary_audit 
ON SCHEDULE EVERY 1 WEEK
STARTS CURRENT_DATE DO 
BEGIN
DELETE FROM salary_audit WHERE date_modified < DATE_ADD(CURDATE(), INTERVAL -7 day);
END $$
DELIMITER ;

检查 EVENTS：
mysql> SHOW EVENTS\G 
mysql> SHOW CREATE EVENT purge_salary_audit\G 
启用或禁用某个事件：
mysql> ALTER EVENT purge_salary_audit DISABLE;
mysql> ALTER EVENT purge_salary_audit ENABLE;

MySQL 8 触发器的创建与操作 
原创 创建时间：2019-01-28  访问量：32  赞：0  踩：0 
触发器是指在某个事件之前或之后执行某些特定的操作。触发器的动作时间有BEFOR和AFTER，这表示在数据库表的某一行发生修改事件之前或之后调用。
触发器三个事件：INSERT，DELETE 和 UPDATE。
INSERT：表示通过INSERT，REPLACE或LOAD DATE插入一行时调用触发器
UPDATE：表示在执行 UPDATE 语句时执行触发器
DELETE：表示在执行 DELETE 或 REPLACE 语句时执行触发器
可以使用多个触发器，并通过 FOLLOWS 或 PRECEDES 关键字指定触发器调用的先后顺序。
例如，对 salaries 表中的 sarary 在插入时进行四舍五入处理后再插入，创建一个BEFOR INSERT触发器：
shell> vi before_insert_trigger.sql
DROP TRIGGER IF EXISTS salary_round;
DELIMITER $$
CREATE TRIGGER salary_round BEFORE INSERT ON salaries
FOR EACH ROW
BEGIN
SET NEW.salary=ROUND(NEW.salary);
END
$$
DELIMITER ;
通过SOURCE语句创建触发器：
mysql> SOURCE before_insert_trigger.sql;
Query OK, 0 rows affected (0.06 sec)
Query OK, 0 rows affected (0.00 sec)
测试这个触发器：
mysql> INSERT INTO salaries VALUES(10002, 100000.79,
CURDATE(), '9999-01-01');
Query OK, 1 row affected (0.04 sec)

mysql> SELECT * FROM salaries WHERE emp_no=10002 AND
from_date=CURDATE();
+--------+--------+------------+------------+
| emp_no | salary | from_date | to_date |
+--------+--------+------------+------------+
| 10002 | 100001 | 2017-06-18 | 9999-01-01 |
+--------+--------+------------+------------+
1 row in set (0.00 sec)
创建一个BEFORE UPDATE 触发器：
# 选创建一张表
mysql> CREATE TABLE salary_audit (emp_no int, user
varchar(50), date_modified date);

# 再创建一个触发器，注意是在salary_round之前执行的，所以使用了 PRECEDES
shell> vi before_insert_trigger.sql
DELIMITER $$
CREATE TRIGGER salary_audit
BEFORE INSERT
ON salaries FOR EACH ROW PRECEDES salary_round
BEGIN
INSERT INTO salary_audit VALUES(NEW.emp_no,
USER(), CURDATE());
END; $$
DELIMITER ;
 创建并测试：
mysql> INSERT INTO salaries VALUES(10003, 100000.79,
CURDATE(), '9999-01-01');
Query OK, 1 row affected (0.06 sec)

mysql> SELECT * FROM salary_audit WHERE emp_no=10003;
+--------+----------------+---------------+
| emp_no | user | date_modified |
+--------+----------------+---------------+
| 10003 | root@localhost | 2017-06-18 |
+--------+----------------+---------------+
1 row in set (0.00 sec)
查看所有触发器：
SHOW TRIGGERS\G  
查看某个触发器：
SHOW CREATE TRIGGER <trigger name>\G 

1、获取当前日期 CURDATE()：
