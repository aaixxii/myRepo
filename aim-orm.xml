<?xml version="1.0" encoding="UTF-8"?>
<entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/persistence/orm http://java.sun.com/xml/ns/persistence/orm_2_0.xsd"
	version="2.0">
	
<!-- ==== Segment report related ==== -->
<named-query name="NQ::getSegReportsForMuid">
<query>
select r FROM MuSegReportEntity r WHERE r.muId = :muId
</query>
</named-query>

<!-- ==== Match Unit Map Reduce / Match Manager related ==== -->
<named-query name="NQ::lookupMM">
<query>
select mm FROM MatchManagerEntity mm WHERE mm.uniqueId = :uniqueId
</query>
</named-query>
<named-query name="NQ::lookupMU">
<query>
select mu FROM MatchUnitEntity mu WHERE mu.uniqueId = :uniqueId
</query>
</named-query>

<named-query name="NQ::lookupMR">
<query>
select mr FROM MapReducerEntity mr WHERE mr.uniqueId = :uniqueId
</query>
</named-query>

<named-query name="NQ::lookupSM">
<query>
select sm FROM SystemManagerEntity sm WHERE sm.uniqueId = :uniqueId
</query>
</named-query>


<named-query name="NQ::listWorkingMUs">
<query>
SELECT mue FROM MatchUnitEntity mue WHERE mue.state = 'WORKING' 
</query>
</named-query>

<named-query name="NQ:getSystemInitEntity">
<query>
SELECT s FROM SystemInitEntity s WHERE s.keyName = :key		
</query>	
</named-query>

<!-- ==== Job related ==== -->
<named-query name="NQ::allJobIds">
<query>
SELECT j.jobId FROM JobQueueEntity j
</query>
</named-query>

<named-query name="NQ::allExtractJobIds">
<query>
SELECT e.id FROM FeJobQueueEntity e
</query>
</named-query>

<named-query name="NQ::getExResulst">
<query>
SELECT e FROM FeJobQueueEntity e where e.referenceId= :refId order by e.submissionTs DESC
</query>
</named-query>

<named-query name="NQ::isHaveTemplateData">
<query>
SELECT e FROM FeJobQueueEntity e where e.referenceId= :refId and e.tempalteData is not null
</query>
</named-query>


<named-query name="NQ::getFeJobPayload">
<query>
SELECT e FROM FeJobPayloadEntity e where e.jobId= :feJobId
</query>
</named-query>

<named-query name="NQ::clearJobs">
<query>
DELETE FROM JobQueueEntity
</query>
</named-query>

<named-query name="NQ::delBioUsingEnrollId">
<query>
DELETE FROM PersonBiometricEntity where externalId =:enrollId
</query>
</named-query>

<named-query name="NQ::getBioDataCount">
<query>
SELECT count(e) FROM  PersonBiometricEntity e 
</query>
</named-query>

<named-query name="NQ::delMrPlanById">
<query>
DELETE FROM  MrJobPlansEntity WHERE batchJobPlanId=:planId AND mrId=:mrId
</query>
</named-query>

<named-query name="NQ::listWorkingMMs">
<query>
SELECT mme FROM MatchManagerEntity mme WHERE mme.state = 'WORKING' 
</query>
</named-query>

<named-query name="NQ::getWorkingContainerJobs">
<query>
SELECT cje FROM ContainerJobEntity cje WHERE cje.jobState &lt;= 1 AND cje.mrId is not null
</query>
</named-query>

<named-query name="NQ::listEligibleMUs">
<query>
SELECT mu FROM MatchUnitEntity mu, MuEligibleContainerEntity mec 
 WHERE mu.muId = mec.id.muId AND mu.state = 'WORKING' AND mec.id.containerId = :containerId
 order by mu.muId 
</query>
</named-query>

<named-query name="NQ::listDeadContainerJobs">
<query>
select cj FROM ContainerJobEntity cj WHERE cj.jobState &lt; 2 and cj.mrId IN :mrIds ORDER BY cj.containerJobId
</query>
</named-query>

<named-query name="NQ::deadContainerJobs">
<query>
select cj FROM ContainerJobEntity cj WHERE cj.jobState &lt; 2 and cj.mrId = :mrId ORDER BY cj.containerJobId
</query>
</named-query>

<named-query name="NQ::listContainers">
<query>
SELECT c FROM ContainerEntity c ORDER BY c.containerId
</query>
</named-query>

<named-query name="NQ::clearExtractJobs">
<query>
DELETE FROM FeJobQueueEntity
</query>
</named-query>

<named-query name= "NQ::getConfigEntity">
<query>
SELECT a FROM SystemConfigEntity a WHERE a.name = :name 
</query>
</named-query>
 
 <named-query name="NQ::getFeResultByjobId">
<query>
SELECT a FROM FeResultEntity a WHERE a.jobId = :jobId  
</query>
</named-query>

<named-query name="NQ::getFeResult">
<query>
SELECT a FROM FeResultEntity a WHERE a.jobId = :jobId AND a.templateKey = :templateKey 
</query>
</named-query>

<named-query name="NQ::getFeResultByIndexr">
<query>
SELECT a FROM FeResultEntity a 
WHERE a.jobId = :jobId 
AND a.templateKey = :templateKey 
AND a.templateIndex = :templateIndex
</query>
</named-query>
  
<named-query name="NQ::getFunctionByType">
<query>
SELECT fte FROM FunctionTypeEntity fte WHERE fte.type = :type order by fte.id
</query>
</named-query>

<named-query name="NQ::getExtractTimeouts">
<query>
SELECT ft.topLevelJobTimeouts FROM FunctionTypeEntity ft WHERE ft.functionName = 'EXTRACTION'
</query>
</named-query>

<named-query name="NQ::getFunctionByName">
<query>
SELECT e FROM FunctionTypeEntity e WHERE e.functionName = :name
</query>
</named-query>

<named-query name="NQ::checkEnrollmentID">
<query>
SELECT e FROM PersonBiometricEntity e WHERE e.externalId = :enrollId
</query>
</named-query>

<named-query name="NQ::isHaveBiometricData">
<query>
select p from PersonBiometricEntity p where p.externalId=:refId and p.corruptedFlag=0 and p.registedTs is not null
</query>
</named-query>

<named-query name="NQ::deleteExtJobByRefernceId">
<query>
 DELETE FROM FeJobQueueEntity where referenceId =:referenceId
</query>
</named-query>

<named-query name="NQ::updatePartitionSaveDays">
<query>
UPDATE SystemInitEntity s set s.keyValue=:value WHERE s.keyName='SEGMENT_CHANGE_LOG_SAVE_DAYS'
</query>
</named-query>

<named-query name="NQ::updateInUsingAdjuist">
<query>
UPDATE SystemInitEntity s set s.keyValue=:value WHERE s.keyName='IN_USING_ADJUST'
</query>
</named-query>

<named-query name="NQ::getAllMqSetting">
<query>
select e from RqSettingEntity e
</query>
</named-query>

<named-query name="NQ::updateMqMasterNode">
<query>
UPDATE RqSettingEntity r set r.masterNode=:masterNode, r.ts=:newTs WHERE r.id=:id
</query>
</named-query>

<named-query name="NQ::updateSegmentVersion">
<query>
UPDATE SegmentEntity s set s.version=:segVer, s.revision=:revision WHERE s.segmentId=:segId
</query>
</named-query>

<!-- ========================= NATIVE QUERIES ========================= -->
<named-native-query name="NQ::getMuSegmentUpdates" result-class="jp.co.nec.aim.mm.entities.MapReportCombinedEntity">
<query>
SELECT a.MU_ID as unitId, 
       a.SEGMENT_ID as segmentId,
       a.rank as rank,
       a.status as status,
       a.segment_version as reportVersion,
       a.segment_queued_version as reportQueuedVersion,
       s.version as latestVersion, 
       get_source_url(s.segment_id) as sourceURLBase 
FROM (SELECT * FROM  mu_seg_reports full outer join mu_segments USING (mu_id, segment_id)) a 
LEFT JOIN segments s ON  a.segment_id = s.segment_id
LEFT JOIN match_units mu ON mu.mu_id = a.mu_id
WHERE mu.mu_id = :muId
AND ( s.version is null or a.rank is null or a.status is null or a.segment_queued_version is null or a.segment_queued_version != s.version )
</query>
</named-native-query>

<named-native-query name="NQ::getDmSegmentUpdates" result-class="jp.co.nec.aim.mm.entities.MapReportCombinedEntity">
<query>
SELECT a.dm_id as unitId, 
       a.segment_id as segmentId,
       a.rank as rank,
       a.status as status,
       a.segment_version as reportVersion,
       a.segment_version as reportQueuedVersion,
       s.version as latestVersion, 
       get_source_url(s.segment_id) as sourceURLBase 
FROM (SELECT * FROM  dm_seg_reports full outer join dm_segments USING (dm_id, segment_id)) a 
LEFT JOIN segments s ON  a.segment_id = s.segment_id
LEFT JOIN data_managers dm ON dm.dm_id = a.dm_id
WHERE dm.dm_id = :dmId
AND ( s.version is null or a.rank is null or a.status is null or a.segment_version is null or a.segment_version != s.version )
</query>
</named-native-query>

<named-native-query name="NQ:lockContainerJob" result-set-mapping="NR::containerJobId">
<query>
SELECT CONTAINER_JOB_ID FROM CONTAINER_JOBS WHERE CONTAINER_JOB_ID = :cJobId FOR UPDATE
</query>
</named-native-query>

<named-native-query name="NQ:updateDmContacts" result-set-mapping="dummy">
<query>
UPDATE DM_CONTACTS SET CONTACT_TS= get_epoch_time_num() WHERE DM_ID=:dmId 
</query>
</named-native-query>

<named-native-query name="NQ:createDmContacts" result-set-mapping="dummy">
<query>
INSERT INTO DM_CONTACTS (DM_ID, CONTACT_TS) VALUES(:dmId, UNIX_TIMESTAMP(NOW()))
</query>
</named-native-query>

<named-native-query name="NQ:updateMrContacts" result-set-mapping="dummy">
<query>
UPDATE MR_CONTACTS SET CONTACT_TS= get_epoch_time_num() WHERE MR_ID=:mrId 
</query>
</named-native-query>

<named-native-query name="NQ:createMrContacts" result-set-mapping="dummy">
<query>
INSERT INTO MR_CONTACTS (MR_ID, CONTACT_TS)  VALUES(:mrId, UNIX_TIMESTAMP(NOW()))
</query>
</named-native-query>

<named-native-query name="NQ:updateMuContacts" result-set-mapping="dummy">
<query>
UPDATE MU_CONTACTS SET CONTACT_TS=get_epoch_time_num() WHERE MU_ID=:muId 
</query>
</named-native-query>

<named-native-query name="NQ:createMuContacts" result-set-mapping="dummy">
<query>
INSERT INTO MU_CONTACTS (MU_ID, CONTACT_TS)  VALUES(:muId, UNIX_TIMESTAMP(NOW()))
</query>
</named-native-query>

<named-native-query name="NQ:createMuInquiryLoad" result-set-mapping="dummy">
<query>
INSERT INTO MU_INQUIRY_LOAD (MU_ID, PRESSURE, REPORT_TS)  VALUES(:muId, 0, UNIX_TIMESTAMP(NOW()))
</query>
</named-native-query>

<named-native-query name="NQ:createMuExtractLoad" result-set-mapping="dummy">
<query>
INSERT INTO MU_EXTRACT_LOAD (MU_ID, PRESSURE, UPDATE_TS)  VALUES(:muId, 0, UNIX_TIMESTAMP(NOW()))
</query>
</named-native-query>

<named-native-query name="NQ::addMuEligibleContainers" result-set-mapping="NR::no_results">
<query>
INSERT INTO MU_ELIGIBLE_CONTAINERS (MU_ID, CONTAINER_ID)
SELECT :muId, CONTAINER_ID from CONTAINERS
</query>
</named-native-query>

<named-native-query name="NQ::addDmEligibleContainers" result-set-mapping="NR::no_results">
<query>
INSERT INTO DM_ELIGIBLE_CONTAINERS (DM_ID, CONTAINER_ID)
SELECT :dmId, CONTAINER_ID from CONTAINERS
</query>
</named-native-query>

<named-native-query name="NQ::call_delete_extract_job" result-set-mapping="NR::no_results">
<query>{ call delete_extract_job(:extractJobId) }</query>
</named-native-query>

<named-native-query name="NQ::deleteLotJob" result-set-mapping="NR::no_results">
<query>
 delete from FE_LOT_JOBS where LOT_JOB_ID=:lotJobId
</query>
</named-native-query>

<named-native-query name="NQ::insertMMEvents" result-set-mapping="dummy">
<query>
INSERT INTO MM_EVENTS (NAME, LAST_TS, MM_ID) VALUES (:name, get_epoch_time_num(), :mmId)
</query>
</named-native-query> 

<named-native-query name="NQ::isMatchManagerAlive" result-set-mapping="NR::count">
<query>
select count(LAST_TS) as count from MM_EVENTS where name='STARTUP'
 and LAST_TS &lt; (select get_epoch_time_num() - :milliDuration) 
 limit 1
</query>
</named-native-query>

<named-native-query name="NQ::getWorkingMRCount" result-set-mapping="NR::count">
<query>
SELECT count(MR_ID) as count FROM MAP_REDUCERS mr WHERE mr.STATE = 'WORKING'
</query>
</named-native-query>

<named-native-query name="NQ::clearFeJobQueueByResultTs" result-set-mapping="dummy"> 
<query>
delete from FE_JOB_QUEUE where
  JOB_STATE = 2
  and RESULT_TS &lt;
  (
    select (get_epoch_time_num() - CAST(PROPERTY_VALUE AS UNSIGNED)*3600000)
       from SYSTEM_CONFIG where PROPERTY_NAME='PURGE_JOB_QUEUE.PERIOD_HOUR'
  )
</query>
</named-native-query>

<named-native-query name="NQ::clearJobQueueByResultTs" result-set-mapping="dummy">
<query>
delete from JOB_QUEUE where 
  JOB_STATE = 2
  and RESULT_TS &lt;
  (
     select (get_epoch_time_num() -  CAST(PROPERTY_VALUE AS UNSIGNED)*3600000)
        from SYSTEM_CONFIG where PROPERTY_NAME='PURGE_JOB_QUEUE.PERIOD_HOUR'
  )
</query>
</named-native-query>

<named-native-query name="NQ::updateMMEvents" result-set-mapping="dummy">
<query>
UPDATE MM_EVENTS SET LAST_TS=get_epoch_time_num(), MM_ID=:mmId WHERE NAME=:name
</query>
</named-native-query>

<named-native-query  name="NQ::getSegmentIds" result-set-mapping="NR::segmentid">
<query>
select SEGMENT_ID from SEGMENTS where CONTAINER_ID=:containerId order by SEGMENT_ID
</query>
</named-native-query>

<named-native-query  name="NQ:passedEnough" result-set-mapping="NR::count">
<query>
select count(LAST_TS) as count from MM_EVENTS where name=:name 
and LAST_TS &lt;
	(select get_epoch_time_num()-:interval-:limit diff from dual)
</query>
</named-native-query>

<named-native-query name="NQ::createMatchManagerEntity" result-set-mapping="dummy">
<query>
INSERT INTO MATCH_MANAGERS (UNIQUE_ID, STATE, CONTACT_URL, HEARTBEAT_TS, VERSION)
  VALUES (:uniqueId, 'WORKING', :contactUrl, get_epoch_time_num(), :version)
</query>
</named-native-query>

<named-native-query name="NQ::updateMatchManagerEntity" result-set-mapping="dummy">
<query>
UPDATE MATCH_MANAGERS SET STATE='WORKING', CONTACT_URL=:contactUrl, VERSION=:version, HEARTBEAT_TS=get_epoch_time_num()
  WHERE UNIQUE_ID=:uniqueId
</query>
</named-native-query>

<named-native-query name="NQ::listDeadMMs" result-class="jp.co.nec.aim.mm.entities.MatchManagerEntity">
<query>
select * from MATCH_MANAGERS where STATE='WORKING' AND HEARTBEAT_TS &lt; 
 (select ( get_epoch_time_num()- CAST(PROPERTY_VALUE AS UNSIGNED) ) as diff from SYSTEM_CONFIG where PROPERTY_NAME = 'TIMEOUTS.HEARTBEAT_MESSAGE')
</query>
</named-native-query>

<named-native-query name="NQ::decreaseExtractLoad" result-set-mapping="dummy">
<query>
update MU_EXTRACT_LOAD set PRESSURE = CASE PRESSURE when 0 then 0 else PRESSURE - 1 end where MU_ID=:muId
</query>
</named-native-query>

<named-native-query name="NQ::getContainerJobId" result-set-mapping="NR::containerJobId">
<query>
select cj.CONTAINER_JOB_ID from CONTAINER_JOBS cj
where cj.PLAN_ID = :planId 
and cj.JOB_STATE = 1
</query>
</named-native-query>

<named-native-query name="NQ::getJobQueueByContainerJobId" result-set-mapping="NR::JobQueueEntity">
<query>
select jq.* from JOB_QUEUE jq , FUSION_JOBS fj , CONTAINER_JOBS cj 
where jq.JOB_ID=fj.JOB_ID and fj.FUSION_JOB_ID=cj.FUSION_JOB_ID 
and cj.CONTAINER_JOB_ID=:containerJobId
</query>
</named-native-query>

<named-native-query name="NQ::getInquiryTraffic" result-set-mapping="NR::InquiryTrafficEntity">
<query>
select it.* from INQUIRY_TRAFFIC it,JOB_QUEUE jq 
where it.FAMILY_ID = jq.FAMILY_ID 
and jq.JOB_ID = :jobId 
</query>
</named-native-query>

<named-native-query name="NQ::GetAllContainerJob" result-set-mapping="NR::ContainerJobEntity">
<query>
select cj.* 
from JOB_QUEUE jq, FUSION_JOBS fj, CONTAINER_JOBS cj 
where jq.JOB_ID=fj.JOB_ID 
and fj.FUSION_JOB_ID=cj.FUSION_JOB_ID 
and jq.JOB_ID=:jobId 
order by cj.CONTAINER_JOB_ID
</query>
</named-native-query>
<!--
<named-native-query name="NQ::getFunctionFamily" result-set-mapping="NR::getFunctionFamily">
<query>
select f.function_family from function_types f, fusion_jobs fj where f.function_id = fj.function_id and fj.job_id = :jobId
</query>
</named-native-query>
-->
<named-native-query name="NQ::clearAllContainerJobs">
<query>
delete from CONTAINER_JOBS 
where CONTAINER_JOB_ID in 
(select tmp.CONTAINER_JOB_ID from 
(select cj.CONTAINER_JOB_ID from FUSION_JOBS  fj,CONTAINER_JOBS cj
where fj.FUSION_JOB_ID=cj.FUSION_JOB_ID
and fj.JOB_ID=:jobId) as tmp)
</query>
</named-native-query>

<named-native-query name="NQ::getFusionJob" result-set-mapping="NR::FusionJobEntity">
<query>
	select * from FUSION_JOBS fj 
	where 
		fj.FUSION_JOB_ID = :fusionJobId and
		fj.FUNCTION_ID = :functionId
	order by
		fj.SEARCH_REQUEST_INDEX
</query>
</named-native-query>

<named-native-query name="NQ::listTimedOutJobs" result-set-mapping="NR::ContainerJobEntity">
<query>
SELECT cj.* FROM CONTAINER_JOBS cj, FUSION_JOBS fj, FUNCTION_TYPES ft 
WHERE ft.FUNCTION_NAME = :functionName AND ft.FUNCTION_ID  = fj.FUNCTION_ID  AND fj.FUSION_JOB_ID  = cj.FUSION_JOB_ID  
 AND cj.JOB_STATE = 1  
 AND cj.ASSIGNED_TS &lt; (SELECT get_epoch_time_num() - ft.CONTAINER_JOB_TIMEOUTS)
 ORDER BY cj.CONTAINER_JOB_ID
 limit :rownum 
</query>
</named-native-query>

<named-native-query name="NQ::listTimedOutMRs" result-set-mapping="NR::MapReducerEntity">
<query>
SELECT mr.* FROM MAP_REDUCERS mr INNER JOIN MR_CONTACTS mrc ON mrc.MR_ID = mr.MR_ID 
 WHERE mr.STATE = 'WORKING' AND mrc.CONTACT_TS  &lt; 
 (SELECT get_epoch_time_num() - CAST(PROPERTY_VALUE AS UNSIGNED) from SYSTEM_CONFIG where PROPERTY_NAME  = 'TIMEOUTS.HEARTBEAT_MESSAGE')
  order by mr.MR_ID
</query>
</named-native-query>

<named-native-query name="NQ::listTimedOutMUs" result-set-mapping="NR::MatchUnitEntity">
<query>
SELECT mu.* FROM MATCH_UNITS mu INNER JOIN MU_CONTACTS muc ON muc.MU_ID = mu.MU_ID 
 WHERE mu.STATE = 'WORKING' AND muc.CONTACT_TS  &lt; 
 (SELECT get_epoch_time_num() - CAST(PROPERTY_VALUE AS UNSIGNED) from SYSTEM_CONFIG where PROPERTY_NAME  = 'TIMEOUTS.HEARTBEAT_MESSAGE')
  order by mu.MU_ID
</query>
</named-native-query>


<named-native-query name="NQ::listDeadExtractJobs" result-set-mapping="NR::FeJobQueueEntity">
<query>
select ejq.* from FE_JOB_QUEUE ejq where ejq.JOB_STATE = 1 and ejq.MU_ID=:muId ORDER BY ejq.JOB_ID
</query>
</named-native-query>

<named-native-query name="NQ::listTimedOutExtractJobs" result-set-mapping="NR::FeJobQueueEntity">
<query>
SELECT ejq.* FROM FE_JOB_QUEUE ejq, FE_LOT_JOBS flj,MATCH_UNITS mu 
WHERE ejq.JOB_STATE=1 AND mu.MU_ID = ejq.MU_ID AND ejq.LOT_JOB_ID = flj.LOT_JOB_ID  
 AND (mu.STATE not in ('WORKING') OR ejq.ASSIGNED_TS &lt; (get_epoch_time_num() - flj.TIMEOUTS))
  ORDER BY ejq.JOB_ID
  limit :rownum
</query>
</named-native-query>

<named-native-query name="NQ::getDMSegmetMaps" result-class="jp.co.nec.aim.mm.entities.UnitSegMap">
<query>
 select DM_ID as UNIT_ID, SEGMENT_ID from DM_SEG_REPORTS where STATUS &lt;= 1
 and DM_ID in (:unitIds) order by UNIT_ID, SEGMENT_ID
</query>
</named-native-query>

<named-native-query name="NQ::getMUSegmetMaps" result-class="jp.co.nec.aim.mm.entities.UnitSegMap">
<query>
 select MU_ID as UNIT_ID, SEGMENT_ID from MU_SEG_REPORTS where STATUS &lt;= 1
 and MU_ID in (:unitIds) order by UNIT_ID, SEGMENT_ID
</query>
</named-native-query>

<named-native-query name="NQ::deleteTimeoutDmSeg">
<query>
Delete from DM_SEGMENTS where DM_ID not in (:unitIds) and SEGMENT_ID in (:segIds)
</query>
</named-native-query>

<named-native-query name="NQ::deleteTimeoutMuSeg">
<query>
Delete from MU_SEGMENTS where MU_ID not in (:unitIds) and SEGMENT_ID in (:segIds)
</query>
</named-native-query>

<named-native-query name="NQ::getContainerJob"  result-set-mapping="NR::ContainerJobEntity">
<query>
select cj.* from CONTAINER_JOBS cj 
where  cj.CONTAINER_ID=:containerId 
and cj.FUSION_JOB_ID=:fusionJob
</query>
</named-native-query>

<named-native-query name="NQ::findMinFunctionId" result-set-mapping="NR::function_id">
<query>
select MIN(fFUNCTION_ID) as function_id from FUNCTION_TYPES where FUNCTION_NAME in (
  (select replace(FUNCTION_NAME , '-S', '') from 
    (select FUNCTION_NAME  from FUSION_JOBS fj, FUNCTION_TYPES ft where fj.JOB_ID=:jobId
     and fj.FUNCTION_ID=ft.FUNCTION_ID)
  )
)
</query>
</named-native-query>



<named-native-query name="NQ::countUnfinishedForJob" result-set-mapping="NR::count">
<query>
select count(*) as count 
from JOB_QUEUE jq, FUSION_JOBS fj, CONTAINER_JOBS cj
where jq.JOB_ID = fj.JOB_ID
  and fj.FUSION_JOB_ID = cj.FUSION_JOB_ID 
  and cj.JOB_STATEe != 2
  and jq.JOB_ID = :jobId
</query>
</named-native-query>

<sql-result-set-mapping name="NR::no_results" />
<!--
<sql-result-set-mapping name="NR::getFunctionFamily">
<column-result name="function_family"/>
</sql-result-set-mapping>
-->

<sql-result-set-mapping name="NR::MatchUnitEntity">
	<entity-result entity-class="jp.co.nec.aim.mm.entities.MatchUnitEntity"/>
</sql-result-set-mapping>



<sql-result-set-mapping name="NR::MapReducerEntity">
	<entity-result entity-class="jp.co.nec.aim.mm.entities.MapReducerEntity"/>
</sql-result-set-mapping>

<sql-result-set-mapping name="NR::JobQueueEntity">
	<entity-result entity-class="jp.co.nec.aim.mm.entities.JobQueueEntity"/>
</sql-result-set-mapping>

<sql-result-set-mapping name="NR::FusionJobEntity">
	<entity-result entity-class="jp.co.nec.aim.mm.entities.FusionJobEntity"/>
</sql-result-set-mapping>

<sql-result-set-mapping name="NR::ContainerJobEntity">
	<entity-result entity-class="jp.co.nec.aim.mm.entities.ContainerJobEntity"/>
</sql-result-set-mapping>

<sql-result-set-mapping name="NR::FeJobQueueEntity">
	<entity-result entity-class="jp.co.nec.aim.mm.entities.FeJobQueueEntity"/>
</sql-result-set-mapping>

<sql-result-set-mapping name="NR::segmentid">
	<column-result name="SEGMENT_ID"/>
</sql-result-set-mapping>

<sql-result-set-mapping name="NR::containerJobId">
	<column-result name="CONTAINER_JOB_ID"/>
</sql-result-set-mapping>

<sql-result-set-mapping name="NR::InquiryTrafficEntity">
	<entity-result entity-class="jp.co.nec.aim.mm.entities.InquiryTrafficEntity"></entity-result>
</sql-result-set-mapping>

<sql-result-set-mapping name="NR::function_id">
	<column-result name="FUNCTION_ID"/>
</sql-result-set-mapping>

<sql-result-set-mapping name="dummy">
    <column-result name="bla" />
</sql-result-set-mapping>

<sql-result-set-mapping name="NR::count">
	<column-result name="count"/>
</sql-result-set-mapping>
</entity-mappings>