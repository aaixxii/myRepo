. 按同一顺序访问对象。 
       . 避免事务中的用户交互。 
       . 保持事务简短并处于一个批处理中。 
       . 使用较低的隔离级别。 
       . 使用基于行版本控制的隔离级别。 
              . 将 READ_COMMITTED_SNAPSHOT 数据库选项设置为 ON，使得已提交读事务使用行版本控制。 
              . 使用快照隔离。 
       . 使用绑定连接。 


 select * from table1 with(updlock) where .... 


总结一下，就是说，某个query使用非聚集索引来select数据，那么它会在非聚集索引上持有一个S锁。
当有一些select的列不在该索引上，它需要根据rowid找到对应的聚集索引的那行，然后找到其他数据。
而此时，第二个的查询中，update正在聚集索引上忙乎：定位、加锁、修改等。
但因为正在修改的某个列，是另外一个非聚集索引的某个列，所以此时，它需要同时更改那个非聚集索引的信息
，这就需要在那个非聚集索引上，加第二个X锁。select开始等待update的X锁，update开始等待select的S锁，死锁，就这样发生鸟。